# Report Task 3: fuzzing, oracles and property based testing

Student: Mayara SIMOES DE OLIVEIRA CASTRO
--
In this task We test the MyFENParser by implementing grammar-based fuzzing and mutation techniques on FEN strings. We generate diverse inputs using a defined grammar and an oracle runner to evaluate the parser’s robustness against potential edge cases and bugs.


```
f := PzGrammarFuzzer on: MyFENPaserGrammar new.

corpus := (1 to: 10) collect: [ :e | f fuzz ].
mutationFuzzer := PzMutationFuzzer new mutations: {FENSwapRanksMutation new. FENSwapMetadataMutation new}.
mutationFuzzer seed: corpus.

ra := FENOracle on: [ :e | MyFENParser parse: e ].
mutationFuzzer run: ra times: 10.
```

In this code snippet:

-	**Fuzzer Creation**: A fuzzer is created using the MyFENParserGrammar, which generates random FEN strings based on the defined grammar.
-	**Corpus Generation**: A corpus of FEN strings is generated by collecting results from the fuzzer.
-	**Mutation**: The PzMutationFuzzer is initialized with mutations for swapping ranks and metadata, allowing for variations in the generated FEN strings.
-	**Testing with Oracle**: The mutated FEN strings are then tested against the MyFENParser using an oracle runner, which checks if the parser handles the mutations correctly.


# Grammar Design
The code for the grammar can be found in: `src/Myg-Chess-Fuzzer/MyFENPaserGrammar.class.st`
### The Chess Board (Ranks):
The main chunk of the FEN string is the board, described with 8 ranks. Each rank has either:
-	A mix of chess pieces (like pawns, rooks, knights, etc.) and empty squares(numbers representing the amount of following empty squares).

```
ntRowContent --> ntPiece , ntPiece , ntPiece , ntPiece , ntPiece , ntPiece , ntPiece , ntPiece | ntSquarePlacement , ntSquarePlacement , ntSquarePlacement , ntSquarePlacement , ntSquarePlacement , ntSquarePlacement , ntSquarePlacement , ntSquarePlacement .
	ntSquarePlacement --> ntEmptySquare @ 50 | ntPiece @ 50 .
	ntEmptySquare --> ($1-$8).
```

### The metadata Game Information:
-	**Whose turn it is**: It’s always either White’s (w) or Black’s (b) turn, so the rule here is very straightforward.
```
ntActiveColor --> 'w' | 'b'.
```
-	**Castling rights**: We check if either player can still castle, and this is expressed by letters (K, Q for White’s rights, and k, q for Black’s). If no one can castle anymore, we use a dash (-).
```pharo
ntCastleRights --> ntBlackCastleRights, ntWhiteCastleRights | '-'.
ntWhiteCastleRights --> 'K' | 'Q' | 'KQ' | '-'.
ntBlackCastleRights --> 'k' | 'q' | 'kq' | '-'.
```

-	**En passant**: We either specify the square where en passant is possible or just use a dash if it’s not available.
```
	ntEnPassantSquare --> '-' | ntSquare.
	ntSquare --> ntSquareLetter , ntSquareNumber .
	ntSquareLetter --> 'a' | 'b' | 'c' | 'd' | 'e' | 'f' | 'g'.
	ntSquareNumber --> ($1-$8).
```
-	**Half-move clock**: This counts how many moves have been made since the last capture or pawn advance.
```
	ntHalfMoveClock --> ntNumber .
```
-	**Full-move number**: The total number of moves made so far in the game.
```
	ntFullMoveNumber --> ntNumber .
```

# Mutation Design
Two primary types of mutations were implemented:

- **Rank Swapping Mutation**: This mutation selects two random ranks in the FEN string and swaps their positions.
	-	The FEN string is split into ranks and the game metadata (active color, castling rights, etc.).
	-	Two ranks are selected randomly, and their positions are swapped before reassembling the FEN string.

The code of this mutation can be found in `src/Myg-Chess-Fuzzer/FENSwapRanksMutation.class.st`

- **Metadata Swap Mutation**: This mutation randomly swaps the metadata, such as castling rights or en passant square, to test the impact of such changes.

The code of this mutation can be found in `src/Myg-Chess-Fuzzer/FENSwapMetadataMutation.class.st`

# Oracle Design
An oracle runner was implemented by comparing the output of two different parsers:

- Testing Parser: The parser that we want to test for bugs. It is passed as a block input to the runner.
- API-Based Parser (Oracle): This parser sends the FEN string to an external chess API to verify the legality of the game state. The API returns an error if the FEN string is invalid.

The runner compares the results of both parsers to identify inconsistencies. If the testing parser accepts a FEN string, but the API-based parser rejects it, OR if the testing parser rejects and the API parser accepts it, then a bug is flagged.

The code of oracle runner can be found in `src/Myg-Chess-Fuzzer/FENOracle.class.st`

# Bugs Found

## Castling Rights Parsing Issue:
**Bug**: The parser does not accept '-' as a valid castling rights indicator when no castling is available. This causes issues with FEN strings that include the '-' symbol for castling rights.

Example:
```
MyFENParser parse: 'rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w - e3 0 1'.
```
This FEN causes an error in the testing parser but is accepted by the API-parser

**Expected Behavior**: The parser should correctly interpret '-' as no castling available.
**Potential Fix**: Modify the castling rights handling logic to accept '-' as valid input alongside K, Q, k, and q.

### Test:
``` 
testAcceptNoCastling

	| parser |

        parser := MyFENParser forString: 'rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w - - 0 1'.

        [parser parse] on: Error do: [ :ex | self fail: 'Unexpected error: ', ex messageText ].

```

## Invalid Handling of Mixed Pieces and Empty Squares:
**Bug**: The parser fails to handle ranks with mixed pieces and empty squares represented by numbers correctly. For example, it does not recognize the FEN string 1r1kq3 and instead expects something like 111 to represent three empty squares.

Example:
````
MyFENParser parse: '1r1k4/8/2P5/8/1p6/8/2K5/8 w KQkq - 0 1'.
````
- **Expected Behavior**: The parser should correctly handle ranks that mix pieces and numbers (e.g., 1r1k4).
- **Potential Fix**: Update the parser logic to properly interpret numbers in ranks as compressed representations of consecutive empty squares, instead of expecting a sequence of 1s.

### Test:
```
testAcceptMultipleEmptySquares

	| parser |

        parser := MyFENParser forString: '1r1k4/8/2P5/8/1p6/8/2K5/8 w KQkq - 0 1'.

        [parser parse] on: Error do: [ :ex | self fail: 'Unexpected error: ', ex messageText ].
```

## En Passant Parsing Issue:
**Bug**: The parser does not correctly handle en passant target squares, causing issues when an en passant square like e3 is included in the FEN string.

Example:
```
MyFENParser parse: 'rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq e3 0 1'. 
````
- **Expected Behavior**: The parser should accept valid en passant target squares (e.g., e3 or -).

- **Potential Fix**: Ensure the en passant square parsing logic supports all valid en passant target squares, including file a through h and rank 1 through 8, as well as the '-' symbol when there is no en passant target.

### Test:
```
testParseEnpassantAcceptPosition

	| parser |

        parser := MyFENParser forString: 'rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq e3 0 1'.

        [parser parse] on: Error do: [ :ex | self fail: 'Unexpected error: ', ex messageText ].
```


## Negative Halfmove Clock and Full Move Number is Accepted

**Bug**: The FEN parser incorrectly accepts negative values for both the halfmove clock and the full move number, which are invalid according to the FEN specification.

Example:
```
MyFENParser parse: '1qqqkbn1/ppppppp1/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - -2 -1'
```

- **Expected Behavior**: The parser should reject FEN strings where the halfmove clock or full move number are negative.

### Tests:
```
testParseNotAcceptNegativeHalfMove

	| parser |

        parser := MyFENParser forString: '1qqqkbn1/ppppppp1/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - -1 0'.

        [parser parse] on: Error do: [ :ex | ^self assert: true. ].

		self fail: 'Expected an error but none was raised'.
```

```
testParseNotAcceptNegativeFullMove

	| parser |

        parser := MyFENParser forString: '1qqqkbn1/ppppppp1/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 -1'.

        [parser parse] on: Error do: [ :ex | ^self assert: true. ].

		self fail: 'Expected an error but none was raised'.
```
